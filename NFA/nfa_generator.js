//README
/**
 * This program was created in webstrom nodejs to run the program
 * please use the following comment on the console to install synchronize read feature.
 * npm --save install readline-sync
 * We used graph structure to create a nfa from given regex.
 * Input string which is taken from user is being validated.
 * To generate postfix format shunting yard algorithm was used.
 * Regex input does not contain '.' needed "." is generated by edit_str function.
 *
 * created by
 * 2015510062 - Ezgi Nur UCAY
 * 2013510028 - Can BÖLEL
 * 2015510109 - S. Serenat YÜCEER
 *
 * */


// Priority of operators.
let opr = {
    "+": 1,
    ".": 2,
    "*": 3,
    ")": 0,
    "(": -1
};
let operator = ["+", ".", "*", ")", "("];

class Vertex {
    // status... accept=2 start=1 both=3..0
    constructor(vertex_id, status) {
        this.vertex_id = vertex_id;
        this.prev_edges = [];
        this.next_edges = [];
        this.status = status;
    }

}

class Edge {
    constructor(edge_id, previous_vertex, next_vertex, transition) {
        this.next_vertex = next_vertex;
        this.previous_vertex = previous_vertex;
        this.transition = transition;
        this.edge_id = edge_id;
        this.b_circular = false; // add this speciality; to goes left edge
    }

}

function shunting_Yard(str) {
    let output_queue = [];
    let operator_stack = [];

    for (let i = 0; i < str.length; i++) {
        if (operator.includes(str[i]) === false) {
            output_queue.push(str[i]);
        }
        else {
            //Operator..

            if (str[i] === "(") {
                operator_stack.push(str[i]);
            } else if (str[i] === ")") {
                do {
                    let parentheses = operator_stack.pop();
                    if (parentheses !== "(") {
                        output_queue.push(parentheses);
                    }
                    else {
                        break;
                    }

                }
                while (true) ;
            }
            else {


                let priority_token = opr[str[i]];
                do {
                    if (operator_stack.length == 0) {
                        break;
                    }
                    else {

                        let stack_value = operator_stack.pop();
                        let priority_operator = opr[stack_value];
                        if (priority_token < priority_operator) {
                            output_queue.push(stack_value);
                        }
                        else {
                            operator_stack.push(stack_value);
                            break;
                        }
                    }
                } while (true);
                //error..
                operator_stack.push(str[i]);
            }

        }
    }
    while (operator_stack.length > 0) {
        let element = operator_stack.pop();
        output_queue.push(element);
    }

    return output_queue;
}

function edit_str(str) {
    let count = 0;
    let str_length = str.length - 1;
    while (count < str_length) {

        if (((operator.includes(str[count]) === false) && (operator.includes(str[count + 1]) === false))
            || (str[count] === "*" && operator.includes(str[count + 1]) === false)
            || (str[count] === ")" && operator.includes(str[count + 1]) === false)
            || (str[count] === "*" && str[count + 1] === "(")) {
            let temp_str = str.substring(count, count + 2);
            let temp = str[count] + "." + str[count + 1];
            regex = regex.replace(temp_str, temp);
        }
        count++;
    }

    return regex;

}

let current_array = [];
let readlineSync = require('readline-sync');
let regex = readlineSync.question('Enter regex ');
let str = readlineSync.question('Enter string ');
let general_state_id = 1;
let general_edge_id = 1;
let stack_graph_array = [];
let flag = false;

TestNFA(regex, str);

function TestNFA(regex, str) {
    console.log('Regex is: ' + regex + ' input string is: ' + str);
    let temp = edit_str(regex);
    regex = temp;
    console.log("edited", regex);
    let postfix = shunting_Yard(regex);
    console.log("postfix:", postfix);

    // This while generates graph from created postfix.
    // Each step of while a character from postfix is being processed and corresponding graph is created.
    while (postfix.length > 0) {
        let element = postfix.shift();

        if (operator.includes(element) == false) {

            let simple_vertex = simple_vertex_generate(element);
            stack_graph_array.push(simple_vertex);


        } else {

            if (element == "*") {
                let v1 = stack_graph_array.pop();
                star_operation(v1);

            }
            else if (element == ".") {
                let v2 = stack_graph_array.pop();
                let v1 = stack_graph_array.pop();
                concat_operation(v1, v2);

            }
            else if (element == "+") {
                let v2 = stack_graph_array.pop();
                let v1 = stack_graph_array.pop();
                union_operation(v1, v2);
            }
            else {
                console.log("somethings go wrong..");
            }

        }
    }
    current_array.push(stack_graph_array[0]);
    current_array = validation(stack_graph_array[0], current_array, str);

    for (let i = 0; i < current_array.length; i++) {
        if (current_array[i].status == 2 || current_array[i].status == 3) {
            flag = true;
            break;
        }
    }


    if (flag === true) {
        console.log("True")
    } else if (flag === false) {
        console.log("false");
    }
    //if no pop.


}

// To generate simple vertex from a char value.
function simple_vertex_generate(input) {

    let v1 = new Vertex(general_state_id, 1);
    general_state_id++;
    let v2 = new Vertex(general_state_id, 2);
    let ed1 = new Edge(general_edge_id, v1, v2, input);
    v2.prev_edges.push(ed1);
    v1.next_edges.push(ed1);
    general_edge_id++;
    general_state_id++;

    return v1;
}

// To star operation of NFA.
function star_operation(token) {
    let v1 = new Vertex(general_state_id, 3); // new vertex start and accept
    let ed1 = new Edge(general_edge_id, v1, token, "$");
    general_edge_id++;
    general_state_id++;
    v1.next_edges.push(ed1);
    token.prev_edges.push(ed1);
    let acceptState = [];
    acceptState = find_Accept_State(v1, acceptState);
    for (let index = 0; index < acceptState.length; index++) {
        let ed2 = new Edge(general_edge_id, acceptState[index], token, "$");
        ed2.b_circular = true;
        acceptState[index].next_edges.push(ed2);
        token.prev_edges.push(ed2);
        general_edge_id++;
    }
    token.status = 0;
    stack_graph_array.push(v1);


}

// To find all possible way from a vertex with '$'
function find_all_possible_way(vertex, current) {

    for (let i = 0; i < vertex.next_edges.length; i++) {
        if (vertex.next_edges[i].transition === "$") {

            if (current.includes(vertex.next_edges[i].next_vertex) === false)
                current.push(vertex.next_edges[i].next_vertex);
            find_all_possible_way(vertex.next_edges[i].next_vertex, current);
        }

    }
    return current;
}

// To find all accepted state.
function find_Accept_State(vertex, accept) {

    if (vertex.status === 2 || vertex.status === 3)
        accept.push(vertex);

    for (let i = 0; i < vertex.next_edges.length; i++) {

        if (vertex.next_edges[i].b_circular != true) {
            find_Accept_State(vertex.next_edges[i].next_vertex, accept);
        }

    }
    return accept;
}

// To concat vertex status for union operation.
function concat_status(vertex) {

    if (vertex.status === 3) {
        vertex.status = 1;
    } else if (vertex.status === 2)
        vertex.status = 0;
    else {
        console.log("Somethings go wrong..");
    }
    return vertex;
}

// To concat operation of NFA.
function concat_operation(first_vertex, second_vertex) {

    let accept = [];
    accept = find_Accept_State(first_vertex, accept);
    for (let i = 0; i < accept.length; i++) {
        let ed1 = new Edge(general_edge_id, accept[i], second_vertex, "$");
        general_edge_id++;
        accept[i] = concat_status(accept[i]);
        accept[i].next_edges.push(ed1);
        second_vertex.prev_edges.push(ed1);

        // accepted state of first vertex become normal state.
        // if the state is both accept and start state status will be 3->1

    }
    if (second_vertex.status === 3) {
        second_vertex.status = 2;
    } else {
        second_vertex.status = 0;
    }

    stack_graph_array.push(first_vertex);

}

// To update vertex status for union operation.
function union_status_operation(vertex) {
    if (vertex.status !== 2) {
        if (vertex.status === 3) {
            vertex.status = 2;
        }
        vertex.status = 0;
    }
    return vertex;
}

// To union operation of NFA.
function union_operation(first_vertex, second_vertex) {

    let new_start = new Vertex(general_state_id, 1);
    general_state_id++;

    first_vertex = union_status_operation(first_vertex);
    let ed1 = new Edge(general_edge_id, new_start, first_vertex, "$");
    general_edge_id++;
    second_vertex = union_status_operation(second_vertex);
    let ed2 = new Edge(general_edge_id, new_start, second_vertex, "$");
    general_edge_id++;
    new_start.next_edges.push(ed1);
    new_start.next_edges.push(ed2);
    stack_graph_array.push(new_start);


}

// Whether regex is validate or not.
function validation(vertex, current, str) {
    let temp_cur_null = [];
    current = find_all_possible_way(vertex, current);
    for (let i = 0; i < str.length; i++) {
        current = transition_check(current, str[i]);

        if (i == str.length - 1) {

            let temp_cur = [];
            for (let j = 0; j < current.length; j++) {
                if (current[j].next_edges.length !== 0) {
                    temp_cur.push(current[j]);
                } else {
                    temp_cur_null.push(current[j]);
                }
            }
            current = [];
            current = temp_cur;
        }
        let temp = [];
        for (let j = 0; j < current.length; j++) {
            temp = find_all_possible_way(current[j], temp);
        }
        current = [];
        current = temp;
    }
    for (let i = 0; i < temp_cur_null.length; i++) {
        current.push(temp_cur_null[i]);
    }

    return current;
}

function transition_check(current, str) {
// str is a char..
    let temp = [];
    for (let j = 0; j < current.length; j++) {

        let current_Vertex = current[j];
        for (let i = 0; i < current_Vertex.next_edges.length; i++) {
            if (current_Vertex.next_edges[i].transition === str) {
                temp.push(current_Vertex.next_edges[i].next_vertex);
            }
        }
        if (current.length === 0) {
            console.log("somethings go wrong..");
        }
    }

    current = temp;
    return current;

}
